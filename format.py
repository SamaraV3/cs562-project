#This contains what i THINK should be generated given some S, n, ..., G
import re
# Test data that matches sales schema - generated by deepseek for testing
cur = [
    {'cust': 'Alice', 'prod': 'Widget', 'day': 1, 'month': 1, 'year': 2023, 'state': 'NY', 'quant': 100, 'date': '2023-01-01'},
    {'cust': 'Alice', 'prod': 'Widget', 'day': 2, 'month': 1, 'year': 2023, 'state': 'NJ', 'quant': 50, 'date': '2023-01-02'},
    {'cust': 'Alice', 'prod': 'Gadget', 'day': 3, 'month': 1, 'year': 2023, 'state': 'NY', 'quant': 75, 'date': '2023-01-03'},
    {'cust': 'Bob', 'prod': 'Widget', 'day': 1, 'month': 1, 'year': 2023, 'state': 'NY', 'quant': 200, 'date': '2023-01-01'},
    {'cust': 'Bob', 'prod': 'Gadget', 'day': 2, 'month': 1, 'year': 2023, 'state': 'CT', 'quant': 25, 'date': '2023-01-02'},
    {'cust': 'Bob', 'prod': 'Gadget', 'day': 3, 'month': 1, 'year': 2023, 'state': 'NJ', 'quant': 150, 'date': '2023-01-03'},
    {'cust': 'Charlie', 'prod': 'Widget', 'day': 1, 'month': 1, 'year': 2023, 'state': 'NJ', 'quant': 80, 'date': '2023-01-01'},
]

# Test MF Query with 2 grouping variables
S = ["cust", "1_sum_quant", "2_count_prod", "2_avg_quant"]  # SELECT
n = 2  # 2 grouping variables
V = ["cust"]  # GROUP BY cust
F = [["1_sum_quant"], ["2_count_prod", "2_avg_quant"]]  # Aggregates for each GV
o = [["1.state='NY'"], ["2.state='NJ'"]]  # Conditions for each GV
G = "1_sum_quant > 50 and 2_count_prod > 0"  # HAVING

def check_condition(row, condition, grouping_var, entry=None):
    #check if row satisfies a condition for a grouping var
    if not condition or condition == "0": #no condition exists for this - assume we good
        return True
    #dont gotta worry abt ands and ors here
    condition_without_gv = condition.replace(f"{grouping_var}.", "", 1) #swap 1.state=NJ with state=NJ
    #lets allow the LIKE operator bcuz im nice like that
    if ' LIKE ' in condition_without_gv.upper():
        parts = re.split(' LIKE ', condition_without_gv, flags=re.IGNORECASE)
        if len(parts) != 2:
            return False
        left = parts[0].strip()
        right = parts[1].strip().strip("'\"")
        if left not in row:
            return False
        row_value = str(row[left]) #row[state] for example
        pattern = right #whatever darn regex we get smdh
        # Convert SQL LIKE pattern to regex: % -> .*, _ -> ., escape other special chars
        pattern = re.escape(pattern)
        pattern = pattern.replace('%', '.*').replace('_', '.')
        pattern = '^' + pattern + '$'

        return bool(re.match(pattern, row_value, re.IGNORECASE))

    operators = ['!=', '>=', '<=', '=', '>', '<'] #i rebuke the energy of any other operators
    for op in operators:
        if op in condition_without_gv:
            left, right = condition_without_gv.split(op, 1) #left=state, right=NJ
            left = left.strip()
            right = right.strip()

            #APPARENTLY this is where u can check if right side references a previous GV attr for emf **tba

            if left not in row:
                return False #attribute doesnt event exist IN the row
            row_value = row[left]

            #handle right side - if its quoted is a string
            if (right.startswith("'") and right.endswith("'")) or \
            (right.startswith('"') and right.endswith('"')):
                right_value = right[1:-1] #remove quotes
                row_str = str(row_value)
                if op == '=':
                    return row_str == right_value
                elif op == '!=':
                    return row_str != right_value
                elif op in ['>', '>=', '<', '<=']:
                    #compare lexicographically
                    if op == '>':
                        return row_str > right_value
                    elif op == '>=':
                        return row_str >= right_value
                    elif op == '<':
                        return row_str < right_value
                    elif op == '<=':
                        return row_str <= right_value

            else:
                #try making it numeric
                try:
                    row_num = float(row_value) if row_value is not None else None
                    right_num = float(right)
                    
                    if row_num is None:
                        return False
                    
                    if op == '=':
                        return abs(row_num - right_num) < 0.000001 #deal with that floating point causing error
                    elif op == '!=':
                        return abs(row_num - right_num) < 0.000001
                    elif op == '>':
                        return row_num > right_num
                    elif op == '>=':
                        return row_num >= right_num
                    elif op == '<':
                        return row_num < right_num
                    elif op == '<=':
                        return row_num <= right_num
                    
                except (ValueError, TypeError):
                    #if if conversion failed i gotta treat them as strings instead
                    row_str = str(row_value)
                    right_str = str(right)
                    if op == '=':
                        return row_str == right_str
                    elif op == '!=':
                        return row_str != right_str
                    elif op == '>':
                        return row_str > right_str
                    elif op == '>=':
                        return row_str >= right_str
                    elif op == '<':
                        return row_str < right_str
                    elif op == '<=':
                        return row_str <= right_str

    return False #the input condition has eluded my capabilities

def evaluate_having(entry, having_condition):
    if not having_condition or having_condition == "0":
        return True
    
    condition_to_eval = having_condition #the entire statement including AND and OR and NOT
    
    # repl agg funcs -> 
    for key in entry.keys():
        if key.startswith(('1_', '2_', '3_', '4_', '5_', '6_', '7_', '8_', '9_')) and '_' in key[2:]:
            condition_to_eval = condition_to_eval.replace(key, f"entry['{key}']")
            #changes 1_sum_quant to entry[1_sum_quant]
    
    #now replace grouping attrs
    for attr in entry.keys():
        if not attr.startswith(('1_', '2_', '3_', '4_', '5_', '6_', '7_', '8_', '9_')):
            condition_to_eval = condition_to_eval.replace(attr, f"entry['{attr}']")
            #changes cust to entry[cust]
    
    #lastly replace grouping var attributes like 1.quant
    for key in entry.keys():
        if key.startswith(('1.', '2.', '3.', '4.', '5.', '6.', '7.', '8.', '9.')):
            condition_to_eval = condition_to_eval.replace(key, f"entry['{key}']")
            #changes 1.quant to entry[1.quant]
    
    try:
        #i wanna see how entry looks btw
        #print(f"entry: {entry}")
        #print(f"condition to eval: {condition_to_eval}")
        return eval(condition_to_eval, {"entry": entry}) #python evals entry[1.quant] > 0 and entry[2_count_prod] == 1 :3
    except:
        return False

def get_select_values(entry, select_attrs):
    result = {}
    for attr in select_attrs:
        if attr in entry:
            # Direct attribute or aggregate
            result[attr] = entry[attr]
        elif '.' in attr:
            # Grouping variable attribute like "1.quant"
            gv_num, gv_attr = attr.split('.', 1)
            storage_key = f"gv_{gv_num}_{gv_attr}"
            if storage_key in entry:
                result[attr] = entry[storage_key]
            else:
                result[attr] = None
        else:
            result[attr] = None
    return result


class MFStruct:
    def __init__(self, proj_attrs, grouping_attrs, agg_func_set, pred_set):
        self.proj_attrs = proj_attrs #S
        self.grouping_attrs = grouping_attrs #V
        self.all_agg_funcs = [item for sublist in agg_func_set for item in sublist] #F - list of lists
        self.pred_set = [item for sublist in pred_set for item in sublist] #o - list of lists
        self.entries = [] 
        #below allows attrs of grouping vars to be viewed
        self.gv_select_attrs = {}
        for attr in self.proj_attrs:
            if '.' in attr and not any(attr.startswith(f"{i}_") for i in range(1, 10)):
                # This is a grouping variable attribute like "1.quant" or "2.state"
                gv_num, gv_attr = attr.split('.', 1)
                if gv_num not in self.gv_select_attrs:
                    self.gv_select_attrs[gv_num] = []
                if gv_attr not in self.gv_select_attrs[gv_num]:
                    self.gv_select_attrs[gv_num].append(gv_attr)


    def populate_entries(self, row):
        group_vals = {}
        for attr in self.grouping_attrs:
            group_vals[attr] = row[attr] #creates col for each grouping_attr + sets to row's acc value for entity
        
        #check if group alr exists
        for entry in self.entries:
            match = all(entry[attr] == group_vals[attr] for attr in self.grouping_attrs)
            if match:
                return entry #group alr exists - exit stage left
        
        new_entry = {}
        for attr in self.grouping_attrs:
            new_entry[attr] = row[attr] #j in case i mutate group_vals
        
        for agg_func in self.all_agg_funcs:
            # agg_func looks like "1_sum_quant", "2_avg_price", etc.
            parts = agg_func.split('_')
            agg_type = parts[1]  # sum, avg, max, min, count
            
            if agg_type == "sum":
                new_entry[agg_func] = 0
            elif agg_type == "count": 
                new_entry[agg_func] = 0
            elif agg_type == "avg":
                new_entry[agg_func] = 0.0
                new_entry[f"{agg_func}_count"] = 0  # For avg computation -> 1_sum_quant_avg
                new_entry[f"{agg_func}_sum"] = 0    # For avg computation
            elif agg_type == "max":
                new_entry[agg_func] = None  # Will be set to first valid value
            elif agg_type == "min":
                new_entry[agg_func] = None  # Will be set to first valid value
        
        #below for grouping attrs
        for gv_num, attrs in self.gv_select_attrs.items():
            for attr in attrs:
                storage_key = f"gv_{gv_num}_{attr}"
                new_entry[storage_key] = None
        
        self.entries.append(new_entry)
        return new_entry
        
    def update_aggregates(self, entry, gv_num, row):
        for agg_func in self.all_agg_funcs:#iterate over all agg_funcs
            if agg_func.startswith(f"{gv_num}_"): #like 1_avg_quant, 2_count_prod, etc
                parts = agg_func.split('_') #will get ["1", "avg", "quant"]
                agg_type = parts[1] #"avg", "count", etc
                attr_name = '_'.join(parts[2:]) #SHOULD j be "quant", "prod", etc
                
                if attr_name not in row:
                    continue  # Skip if attribute doesn't exist in row

                if agg_type == "count" and row[attr_name] is not None:
                    entry[agg_func] += 1 #entry[2_cound_prod] += 1

                else: #if its type aint count
                    try:
                        value = float(row[attr_name])
                    except (ValueError, TypeError):
                        continue
                
                    if agg_type == "sum":
                        entry[agg_func] += value
                    elif agg_type == "max":
                        if entry[agg_func] is None or value > entry[agg_func]:
                            entry[agg_func] = value
                    elif agg_type == "min":
                        if entry[agg_func] is None or value < entry[agg_func]:
                            entry[agg_func] = value
                    elif agg_type == "avg":
                        count_name = f"{agg_func}_count"
                        sum_name = f"{agg_func}_sum"
                        entry[count_name] += 1
                        entry[sum_name] += value
                        if entry[count_name] > 0:
                            entry[agg_func] = entry[sum_name] / entry[count_name]
            
        self.update_gv_attributes(entry, gv_num, row)
    
    #this for grouping var attrs - like 1.quant, 2.state, etc
    def update_gv_attributes(self, entry, gv_num, row):
        if gv_num in self.gv_select_attrs:
            for attr in self.gv_select_attrs[gv_num]:
                if attr in row:
                    storage_key = f"gv_{gv_num}_{attr}"
                    # Store the first value we encounter for this GV attribute
                    if entry[storage_key] is None:
                        entry[storage_key] = row[attr]


mf_struct = MFStruct(S, V, F, o)
for sales_row in cur:
    mf_struct.populate_entries(sales_row)

# to make our lives easier: will detect if query is emf off the bat
is_emf = False #lets assume we r in mf always for now. Edit eventually

for grouping_var in range(1, n+1):
    conditions_list = o[grouping_var-1]
    for sales_row in cur:
        all_conditions_met = True
        for condition in conditions_list:
            if not check_condition(sales_row, condition, str(grouping_var)):
                all_conditions_met = False
                break
        if all_conditions_met: #then sales_row is valid
            if is_emf:#find row in emf where its a matching group - too hard for rn
                pass
            else:
                group_vals = {attr: sales_row[attr] for attr in mf_struct.grouping_attrs}
                matching_entry = None
                for entry in mf_struct.entries:
                    if all(entry[attr] == group_vals[attr] for attr in mf_struct.grouping_attrs):
                        matching_entry = entry
                        break
                if matching_entry:
                    mf_struct.update_aggregates(matching_entry, str(grouping_var), sales_row)

final_results = []
for entry in mf_struct.entries:
    if evaluate_having(entry, G):
        select_vals = get_select_values(entry, S)
        final_results.append(select_vals)

#Print final results
for res in final_results:
    print(res)

print("----------------------------------------------------------------------------------------------")
#below is j testing my check_condition function
# Test your check_condition with various MF conditions
test_row = {'cust': 'Alice', 'state': 'NY', 'quant': 100, 'prod': 'Widget'}

# Test 1: Simple equality
print(check_condition(test_row, "1.state='NY'", "1"))  # Should be True
print(check_condition(test_row, "1.state='NJ'", "1"))  # Should be False

# Test 2: Numeric comparison
print(check_condition(test_row, "1.quant>50", "1"))    # Should be True
print(check_condition(test_row, "1.quant<50", "1"))    # Should be False

# Test 3: LIKE operator
print(check_condition(test_row, "1.state like 'N%'", "1"))    # Should be True
print(check_condition(test_row, "1.state like '%Y'", "1"))    # Should be True
print(check_condition(test_row, "1.state like 'C%'", "1"))    # Should be False

# Test 4: Not equal
print(check_condition(test_row, "1.state!='NJ'", "1"))  # Should be True

# Test 5: String vs numeric handling
print(check_condition(test_row, "1.quant=100", "1"))     # Should be True (numeric)
print(check_condition(test_row, "1.quant='100'", "1"))   # Should be True (string comparison)