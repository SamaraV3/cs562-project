#This contains what i THINK should be generated given some S, n, ..., G

# Test data that matches sales schema - generated by deepseek for testing
cur = [
    {'cust': 'Alice', 'prod': 'Widget', 'day': 1, 'month': 1, 'year': 2023, 'state': 'NY', 'quant': 100, 'date': '2023-01-01'},
    {'cust': 'Alice', 'prod': 'Widget', 'day': 2, 'month': 1, 'year': 2023, 'state': 'NJ', 'quant': 50, 'date': '2023-01-02'},
    {'cust': 'Alice', 'prod': 'Gadget', 'day': 3, 'month': 1, 'year': 2023, 'state': 'NY', 'quant': 75, 'date': '2023-01-03'},
    {'cust': 'Bob', 'prod': 'Widget', 'day': 1, 'month': 1, 'year': 2023, 'state': 'NY', 'quant': 200, 'date': '2023-01-01'},
    {'cust': 'Bob', 'prod': 'Gadget', 'day': 2, 'month': 1, 'year': 2023, 'state': 'CT', 'quant': 25, 'date': '2023-01-02'},
]

# Test query: For each customer, get their total quant in NY and their first NY product
S = ["cust", "1_sum_quant", "1.quant"]  # SELECT includes GV attribute
n = 1
V = ["cust"]
F = [["1_sum_quant"]]  # Just one aggregate for GV1
o = [["1.state='NY'"]]  # Condition for GV1
G = "1_sum_quant > 0"  # Simple HAVING

def check_condition(row, condition, grouping_var):
    #check if row satisfies a condition for a grouping var
    if not condition or condition == "0": #no condition exists for this - assume we good
        return True
    #condits in form 1.state=, 2.quant>, etc
    #remove grouping_var_prefix
    condition_without_gv = condition.replace(f"{grouping_var}.", "", 1)
    operators = ['=', '!=', '>', '>=', '<', '<=']
    for op in operators:
        if op in condition_without_gv:
            left, right = condition_without_gv.split(op, 1) #left of op vs right of op
            left = left.strip()
            right = right.strip().strip("'\"")

            if left not in row:
                return False #attribute doesnt event exist IN the row
            row_value = row[left]

            if op == '=':
                return str(row_value) == right
            elif op == '!=':
                return str(row_value) != right
            elif op == '>':
                return float(row_value) > float(right)
            elif op == '>=':
                return float(row_value) >= float(right)
            elif op == '<':
                return float(row_value) < float(right)
            elif op == '<=':
                return float(row_value) <= float(right)

    return False #the input condition has eluded my capabilities

def evaluate_having(entry, having_condition):
    if not having_condition or having_condition == "0":
        return True
    
    # Replace aggregate references with actual values from entry
    # Example: "1_sum_quant > 2 * 2_sum_quant" becomes "entry['1_sum_quant'] > 2 * entry['2_sum_quant']"
    condition_to_eval = having_condition
    
    # Simple replacement
    for agg_func in mf_struct.all_agg_funcs:
        if agg_func in having_condition:
            condition_to_eval = condition_to_eval.replace(agg_func, f"entry['{agg_func}']")
    
    # Also handle non-aggregate references if any
    for attr in mf_struct.grouping_attrs:
        if attr in having_condition:
            condition_to_eval = condition_to_eval.replace(attr, f"entry['{attr}']")
    
    try:
        return eval(condition_to_eval)
    except:
        return False

def get_select_values(entry, select_attrs):
    result = {}
    for attr in select_attrs:
        if attr in entry:
            # Direct attribute or aggregate
            result[attr] = entry[attr]
        elif '.' in attr:
            # Grouping variable attribute like "1.quant"
            gv_num, gv_attr = attr.split('.', 1)
            storage_key = f"gv_{gv_num}_{gv_attr}"
            if storage_key in entry:
                result[attr] = entry[storage_key]
            else:
                result[attr] = None
        else:
            result[attr] = None
    return result


class MFStruct:
    def __init__(self, proj_attrs, grouping_attrs, agg_func_set, pred_set):
        self.proj_attrs = proj_attrs #S
        self.grouping_attrs = grouping_attrs #V
        self.all_agg_funcs = [item for sublist in agg_func_set for item in sublist] #F - list of lists
        self.pred_set = [item for sublist in pred_set for item in sublist] #o - list of lists
        self.entries = [] 
        #below allows attrs of grouping vars to be viewed
        self.gv_select_attrs = {}
        for attr in self.proj_attrs:
            if '.' in attr and not any(attr.startswith(f"{i}_") for i in range(1, 10)):
                # This is a grouping variable attribute like "1.quant" or "2.state"
                gv_num, gv_attr = attr.split('.', 1)
                if gv_num not in self.gv_select_attrs:
                    self.gv_select_attrs[gv_num] = []
                if gv_attr not in self.gv_select_attrs[gv_num]:
                    self.gv_select_attrs[gv_num].append(gv_attr)


    def populate_entries(self, row):
        group_vals = {}
        for attr in self.grouping_attrs:
            group_vals[attr] = row[attr] #creates col for each grouping_attr + sets to row's acc value for entity
        
        #check if group alr exists
        for entry in self.entries:
            match = all(entry[attr] == group_vals[attr] for attr in self.grouping_attrs)
            if match:
                return entry #group alr exists - exit stage left
        
        new_entry = {}
        for attr in self.grouping_attrs:
            new_entry[attr] = row[attr] #j in case i mutate group_vals
        
        for agg_func in self.all_agg_funcs:
            # agg_func looks like "1_sum_quant", "2_avg_price", etc.
            parts = agg_func.split('_')
            agg_type = parts[1]  # sum, avg, max, min, count
            
            if agg_type == "sum":
                new_entry[agg_func] = 0
            elif agg_type == "count": 
                new_entry[agg_func] = 0
            elif agg_type == "avg":
                new_entry[agg_func] = 0.0
                new_entry[f"{agg_func}_count"] = 0  # For avg computation -> 1_sum_quant_avg
                new_entry[f"{agg_func}_sum"] = 0    # For avg computation
            elif agg_type == "max":
                new_entry[agg_func] = None  # Will be set to first valid value
            elif agg_type == "min":
                new_entry[agg_func] = None  # Will be set to first valid value
        
        #below for grouping attrs
        for gv_num, attrs in self.gv_select_attrs.items():
            for attr in attrs:
                storage_key = f"gv_{gv_num}_{attr}"
                new_entry[storage_key] = None
        
        self.entries.append(new_entry)
        return new_entry
        
    def update_aggregates(self, entry, gv_num, row):
        for agg_func in self.all_agg_funcs:#iterate over all agg_funcs
            if agg_func.startswith(f"{gv_num}_"):
                parts = agg_func.split('_')
                agg_type = parts[1]
                attr_name = '_'.join(parts[2:])
                
                if attr_name not in row:
                    continue  # Skip if attribute doesn't exist in row
                
                try:
                    value = float(row[attr_name])
                except (ValueError, TypeError):
                    continue
                
                if agg_type == "sum":
                    entry[agg_func] += value
                elif agg_type == "count":
                    entry[agg_func] += 1
                elif agg_type == "max":
                    if entry[agg_func] is None or value > entry[agg_func]:
                        entry[agg_func] = value
                elif agg_type == "min":
                    if entry[agg_func] is None or value < entry[agg_func]:
                        entry[agg_func] = value
                elif agg_type == "avg":
                    count_name = f"{agg_func}_count"
                    sum_name = f"{agg_func}_sum"
                    entry[count_name] += 1
                    entry[sum_name] += value
                    if entry[count_name] > 0:
                        entry[agg_func] = entry[sum_name] / entry[count_name]
        self.update_gv_attributes(entry, gv_num, row)
    
    #this for grouping var attrs
    def update_gv_attributes(self, entry, gv_num, row):
        if gv_num in self.gv_select_attrs:
            for attr in self.gv_select_attrs[gv_num]:
                if attr in row:
                    storage_key = f"gv_{gv_num}_{attr}"
                    # Store the first value we encounter for this GV attribute
                    if entry[storage_key] is None:
                        entry[storage_key] = row[attr]


mf_struct = MFStruct(S, V, F, o)
for sales_row in cur:
    mf_struct.populate_entries(sales_row)

# to make our lives easier: will detect if query is emf off the bat
is_emf = False #lets assume we r in mf always for now. Edit eventually

for grouping_var in range(1, n+1):
    conditions_list = o[grouping_var-1]
    for sales_row in cur:
        all_conditions_met = True
        for condition in conditions_list:
            if not check_condition(sales_row, condition, str(grouping_var)):
                all_conditions_met = False
                break
        if all_conditions_met: #then sales_row is valid
            if is_emf:#find row in emf where its a matching group - too hard for rn
                pass
            else:
                group_vals = {attr: sales_row[attr] for attr in mf_struct.grouping_attrs}
                matching_entry = None
                for entry in mf_struct.entries:
                    if all(entry[attr] == group_vals[attr] for attr in mf_struct.grouping_attrs):
                        matching_entry = entry
                        break
                if matching_entry:
                    mf_struct.update_aggregates(matching_entry, str(grouping_var), sales_row)

final_results = []
for entry in mf_struct.entries:
    if evaluate_having(entry, G):
        select_vals = get_select_values(entry, S)
        final_results.append(select_vals)

#Print final results
for res in final_results:
    print(res)